<%!
  from grust.gi import ast
  from grust.gi import message
  from grust.mapping import MappingError
  from grust.mapping import ffi_basic_types
  from grust.mapping import sanitize_ident, to_camel_case
  from grust.mapping import map_constant_value, validate_integer_value

  # Override to suppress C names from the generated output
  suppress_c_names = []

  # Override to ignore nodes with GI names
  skip_names = []
%>\
<%page args="mapper, message_positions"/>\
<%
  namespace = mapper.crate.namespace

  def warn(node, text):
      message.warn_node(node, text, positions=message_positions, context=node)

  def emit(tmpl, node):
      try:
          # Use capture to cull the template output
          # if a recoverable exception is raised.
          context.write(capture(tmpl, node))
      except MappingError as e:
          warn(node, 'representation omitted: {}'.format(e))
%>\
// This file is generated by grust-gen

#![crate_name = "${mapper.crate.name}"]
#![crate_type = "lib"]
<%block name="custom_crate_attributes">\
<%doc>Override to put your crate's custom crate-level attributes here.</%doc>\
</%block>\

extern crate gtypes;
% for xc in mapper.extern_crates():
%     if xc.name == xc.local_name:
extern crate ${xc.name};
%     else:
extern crate ${xc.name} as ${xc.local_name};
%     endif
% endfor

use gtypes::*;

<%block name="custom_types">\
<%doc>Override to put your crate's custom type definitions here.</%doc>\
</%block>\
<%
  NODE_DEFS = {
    ast.Alias: alias,
    ast.Callback: callback,
    ast.Constant: constant,
    ast.Record: struct,
    ast.Class: struct,
    ast.Interface: interface,
    ast.Enum: enum,
    ast.Bitfield: flags
  }

  for node in namespace.names.values():
      if node.__class__ in NODE_DEFS:
          if node.ctype in self.attr.suppress_c_names:
              continue
          if node.name in self.attr.skip_names:
              continue
          emit(NODE_DEFS[node.__class__], node)
      elif isinstance(node, (ast.Function, ast.Signal, ast.Property)):
          continue
      elif isinstance(node, ast.Union):
          # Not supported, but can be suppressed
          if node.ctype in self.attr.suppress_c_names:
              continue
          if node.name in self.attr.skip_names:
              continue
          warn(node,
               ('node type {} is not supported; consider suppressing'
                + ' and providing a custom definition')
               .format(node.__class__.__name__))
      else:
          warn(node,
               'node type {} is not supported'.format(node.__class__.__name__))

  functions = sorted([node for node in namespace.symbols.values()
                      if (isinstance(node, ast.Function)
                          and node.symbol not in self.attr.suppress_c_names
                          and node.name not in self.attr.skip_names)],
                     key=lambda node: node.symbol)
%>
extern {
<%
  for funcnode in functions:
      emit(function, funcnode)
%>\
}
##
<%def name="alias(node)">\
<%
  if node.ctype in ffi_basic_types:
      if namespace.name in ('GLib', 'GObject'):
          # These redundantly introspect GType
          return ''
      raise ConsistencyError(
            'C type name {} conflicts with a fundamental type'
            .format(node.ctype))
%>
pub type ${node.ctype} = ${mapper.map_aliased_type(node)};
</%def>\
##
<%def name="callback(node)">
pub type ${node.ctype} = ${mapper.map_callback(node)};
</%def>\
##
<%def name="constant(node)">
<%
  value_type, value = mapper.map_constant(node)
%>\
pub const ${node.ctype}: ${value_type} = ${value};
</%def>\
##
<%def name="struct(node)">
% if isinstance(node, ast.Record) and node.disguised:
#[repr(C)]
pub struct ${node.ctype}(gpointer);
% elif len(node.fields) == 0:
pub enum ${node.ctype} { }
% else:
#[repr(C)]
pub struct ${node.ctype} {
%     for field in node.fields:
    ${'' if field.private else 'pub '}${sanitize_ident(field.name)}: ${mapper.map_field_type(field)},
%     endfor
}
% endif
</%def>\
##
<%def name="interface(node)">
pub enum ${node.ctype} { }
</%def>\
##
<%def name="_enum_common(node, member_const_tmpl)">\
<%
  # Deduplicate the values
  value_name_map = {}
  for member in node.members:
      validate_integer_value(member.value)
      value = int(member.value)
      if value in value_name_map:
          continue
      value_name_map[value] = to_camel_case(member.name)
  if len(value_name_map) == 1:
      # Work around https://github.com/rust-lang/rust/issues/10292
      value = value_name_map.keys()[0]
      dummy_value = 0 if value != 0 else 1
      value_name_map[dummy_value] = '_Dummy'
%>\
#[repr(C)]
pub enum ${node.ctype} {
% for name, value in [(value_name_map[val], val) for val in sorted(value_name_map.keys())]:
    ${name} = ${value},
% endfor
}
<%
  for member in node.members:
      if member.symbol in self.attr.suppress_c_names:
          continue
      member_const_tmpl(node, member, value_name_map[int(member.value)])
%>\
</%def>\
##
<%def name="enum(node)">
${_enum_common(node, enum_member_const)}\
</%def>\
<%def name="enum_member_const(node, member, value_name)">\
pub const ${member.symbol}: ${node.ctype} = ${node.ctype}::${value_name};
</%def>\
##
<%def name="flags(node)">
${_enum_common(node, flags_member_const)}\
</%def>\
<%def name="flags_member_const(node, member, value_name)">\
## Use the literal value as the enum members cannot be ORed
pub const ${member.symbol}: guint = ${map_constant_value(ast.TYPE_UINT, member.value)};
</%def>\
##
<%def name="function(node)">\
<%
  if any(param.type == ast.TYPE_VALIST for param in node.parameters):
      # Functions with a va_list parameter are usable only in C
      return ''
  parameters = list(node.all_parameters)
  param_list = []
  if len(parameters) > 0 and isinstance(parameters[-1].type, ast.Varargs):
      param_list = ['...']
      del parameters[-1]
  param_list[:0] = ['{name}: {type}'.format(
                        name=sanitize_ident(param.argname),
                        type=mapper.map_parameter_type(param))
                    for param in parameters]
%>\
    pub fn ${node.symbol}(${', '.join(param_list)})\
    % if node.retval.type != ast.TYPE_NONE:
 -> ${mapper.map_return_type(node.retval)}\
    % endif
;
</%def>\
