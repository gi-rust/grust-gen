<%!
  from grust.gi import ast
  from grust.gi import message
  from grust.mapping import MappingError
  from grust.mapping import sanitize_ident, to_camel_case, escape_bytestring
  from grust.mapping import TYPE_STATIC_BYTES_REF
%>\
<%page args="mapper, message_positions"/>\
<%
  namespace = mapper.crate.namespace

  def warn(node, text):
      message.warn_node(node, text, positions=message_positions, context=node)

  def emit(tmpl, node):
      try:
          # Use capture to cull the template output
          # if a recoverable exception is raised.
          context.write(capture(tmpl, node))
      except MappingError as e:
          warn(node, 'representation omitted: {}'.format(e))
%>\
// This file is generated by grust-gen

#![crate_name = "${mapper.crate.name}"]
#![crate_type = "lib"]

extern crate gtypes;
% for xc in mapper.extern_crates():
%     if xc.name == xc.local_name:
extern crate ${xc.name};
%     else:
extern crate ${xc.name} as ${xc.local_name};
%     endif
% endfor

use gtypes::*;

<%
  for node in namespace.names.values():
      node_tmpl = None
      if isinstance(node, ast.Function):
          # TODO: collect functions separately and emit in an extern block
          pass
      elif isinstance(node, ast.Alias):
          node_tmpl = alias
      elif isinstance(node, ast.Callback):
          node_tmpl = callback
      elif isinstance(node, ast.Constant):
          node_tmpl = constant
      elif isinstance(node, (ast.Signal, ast.Property)):
          pass
      elif isinstance(node, (ast.Record, ast.Class)):
          node_tmpl = compound
      elif isinstance(node, ast.Interface):
          node_tmpl = interface
      elif isinstance(node, ast.Enum):
          node_tmpl = enum
      elif isinstance(node, ast.Bitfield):
          node_tmpl = flags
      else:
          warn(node, 'node type {} is not supported'.format(node.__class__.__name__))
      endif
      if node_tmpl:
          emit(node_tmpl, node)

  functions = sorted([node for node in namespace.symbols.values()
                      if isinstance(node, ast.Function)],
                     key=lambda node: node.symbol)
%>
extern {
<%
  for funcnode in functions:
      emit(function, funcnode)
%>\
}
<%def name="alias(node)">
pub type ${node.ctype} = ${mapper.map_aliased_type(node)};
</%def>\
<%def name="callback(node)">
pub type ${node.ctype} = ${mapper.map_callback(node)};
</%def>\
<%def name="constant(node)">
<%
  value_type = mapper.map_const_value_type(node)
%>\
pub const ${node.ctype}: ${value_type} = \
% if value_type == TYPE_STATIC_BYTES_REF:
b"${escape_bytestring(node.value)}\0"\
% else:
${node.value}\
% endif
;
</%def>\
<%def name="compound(node)">
% if len(node.fields) == 0:
pub enum ${node.ctype} { }
% else:
#[repr(C)]
pub struct ${node.ctype} {
%     for field in node.fields:
    ${'' if field.private else 'pub '}${sanitize_ident(field.name)}: ${mapper.map_field_type(field)},
%     endfor
}
% endif
</%def>\
<%def name="interface(node)">
pub enum ${node.ctype} { }
</%def>\
<%def name="_base_enum(node)">\
#[repr(C)]
pub enum ${node.ctype} {
% for member in node.members:
    ${to_camel_case(member.name)} = ${member.value},
% endfor
}
</%def>\
<%def name="enum(node)">
${_base_enum(node)}
% for member in node.members:
pub const ${member.symbol}: ${node.ctype} = ${node.ctype}::${to_camel_case(member.name)};
% endfor
</%def>\
<%def name="flags(node)">
${_base_enum(node)}
% for member in node.members:
pub const ${member.symbol}: guint = ${member.value};
% endfor
</%def>\
<%def name="function(node)">\
<%
  if any(param.type == ast.TYPE_VALIST for param in node.parameters):
      # Functions with a va_list parameter are usable only in C
      return ''
  parameters = list(node.all_parameters)
  param_list = []
  if len(parameters) > 0 and isinstance(parameters[-1].type, ast.Varargs):
      param_list = ['...']
      del parameters[-1]
  param_list[:0] = ['{name}: {type}'.format(
                        name=param.argname,
                        type=mapper.map_parameter_type(param))
                    for param in parameters]
%>\
    pub fn ${node.symbol}(${', '.join(param_list)})\
    % if node.retval.type != ast.TYPE_NONE:
 -> ${mapper.map_return_type(node.retval)}\
    % endif
;
</%def>\
