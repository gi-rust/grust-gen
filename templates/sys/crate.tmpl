<%!
  from grust.gi import ast
  from grust.gi import message
  from grust.mapping import MappingError, sanitize_ident
%>\
<%page args="mapper, message_positions"/>\
<%
  namespace = mapper.crate.namespace

  def warn(node, text):
      message.warn_node(node, text, positions=message_positions, context=node)
%>\
// This file is generated by grust-gen

#![crate_name = "${mapper.crate.name}"]
#![crate_type = "lib"]

extern crate gtypes;
% for xc in mapper.extern_crates():
%     if xc.name == xc.local_name:
extern crate ${xc.name};
%     else:
extern crate ${xc.name} as ${xc.local_name};
%     endif
% endfor

use gtypes::*;

<%
  for node in namespace.names.values():
      node_tmpl = None
      if isinstance(node, ast.Function):
          # TODO: collect functions separately and emit in an extern block
          pass
      elif isinstance(node, ast.Alias):
          node_tmpl = alias
      elif isinstance(node, ast.Record):
          node_tmpl = record
      else:
          warn(node, 'node type {} is not supported'.format(node.__class__.__name__))
      endif
      if node_tmpl:
          try:
              # Use capture to cull the whole node from output
              # if a recoverable exception is raised.
              context.write(capture(node_tmpl, node))
          except MappingError as e:
              warn(node, e)
              warn(node, 'representation omitted')
%>
<%def name="alias(node)">
pub type ${node.ctype} = ${mapper.map_aliased_type(node)};
</%def>\
<%def name="record(node)">
% if len(node.fields) == 0:
pub enum ${node.ctype} { }
% else:
pub struct ${node.ctype} {
%     for field in node.fields:
    ${'' if field.private else 'pub '}${field.name | sanitize_ident}: ${mapper.map_field_type(field)},
%     endfor
}
% endif
</%def>\
