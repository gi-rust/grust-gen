<%!

from grust.giscanner import ast
from grust.giscanner import message
from grust.mapping import MappingError
from grust.mapping import ffi_basic_types
from grust.mapping import sanitize_ident, to_camel_case
from grust.mapping import map_constant_value, validate_integer_value
from grust import __version__ as gen_version

# Override to provide a list of grust.mapping.Module objects
# for sub-namespacing and conditional compilation
modules = []

# Override to suppress C names from the generated output
suppress_c_names = []

# Override to ignore nodes with GI names
ignore_names = []

# Set to true to ignore the get-type functions
ignore_gtype_functions = False

%>\
<%page args="mapper, message_positions"/>\
<%
    namespace = mapper.crate.namespace

    def warn(node, text):
        message.warn_node(node, text, positions=message_positions, context=node)

    def emit_node(tmpl, node, indent=0):

        # Would have used textwrap.indent if not for Python 2
        def indent_lines(text, indent):
            lines = [(' ' * indent + line)
                         if line and not line.isspace() else line
                     for line in text.splitlines(True)]
            return ''.join(lines)

        try:
            # Use capture to cull the template output
            # if a recoverable exception is raised.
            out = capture(tmpl, node)
            if indent > 0:
                out = indent_lines(out, indent)
            context.write(out)
        except MappingError as e:
            warn(node, 'representation omitted: {}'.format(e))
        return ''
%>\
// This file was generated by grust-gen ${gen_version or '(uninstalled)'}

#![crate_name = "${mapper.crate.name}"]
#![crate_type = "lib"]
<%block name="custom_crate_attributes">\
<%doc>Override to put your crate's custom crate-level attributes here.</%doc>\
</%block>\

extern crate gtypes;
%   for xc in mapper.extern_crates():
%       if xc.name == xc.local_name:
extern crate ${xc.name};
%       else:
extern crate ${xc.name} as ${xc.local_name};
%       endif
%   endfor
<%block name="custom_extern_crates">\
<%doc>
  Override to put your crate's custom extern crate declarations here.
</%doc>\
</%block>\

use gtypes::*;

<%block name="custom_types">\
<%doc>Override to put your crate's custom type definitions here.</%doc>\
</%block>\
<%
    node_defs = {
        ast.Alias: alias,
        ast.Callback: callback,
        ast.Constant: constant,
        ast.Record: struct,
        ast.Class: struct,
        ast.Interface: interface,
        ast.Enum: enum,
        ast.Bitfield: flags
    }

    for node in namespace.names.values():
        if node.foreign:
            continue
        if node.__class__ in node_defs:
            if node.ctype in self.attr.suppress_c_names:
                continue
            if node.name in self.attr.ignore_names:
                continue
            emit_node(node_defs[node.__class__], node)
        elif isinstance(node, (ast.Function, ast.Signal, ast.Property)):
            continue
        elif isinstance(node, ast.Union):
            # Not supported, but can be suppressed
            if node.ctype in self.attr.suppress_c_names:
                continue
            if node.name in self.attr.ignore_names:
                continue
            warn(node,
                 ('node type {} is not supported; consider suppressing'
                  + ' and providing a custom definition')
                    .format(node.__class__.__name__))
        else:
            warn(node,
                 'node type {} is not supported'
                    .format(node.__class__.__name__))

    functions = []
    for node in namespace.symbols.values():
        if not isinstance(node, ast.Function):
            continue
        if node.is_type_meta_function():
            continue
        if node.symbol in self.attr.suppress_c_names:
            continue
        if node.name in self.attr.ignore_names:
            continue
        if any(param.type == ast.TYPE_VALIST for param in node.parameters):
            # Functions with a va_list parameter are usable only in C
            continue
        functions.append(node)

    for mod in self.attr.modules:
        functions = mod.extract_functions(functions)

    functions.sort(key=lambda node: node.symbol)
%>
<%block name="custom_constants">\
<%doc>Override to put your crate's custom constant definitions here.</%doc>\
</%block>\
<%block name="custom_extern">\
<%doc>
  If your crate needs to link functions that are not emitted in the
  normal way, override this template block to output an external function
  block or blocks.
</%doc>\
</%block>\
%   if not self.attr.ignore_gtype_functions:
// GType functions
${self.gtype_functions(namespace)}
%   endif
extern {
<%
    for node in functions:
        emit_node(function, node, indent=4)
%>\
}
%   for mod in self.attr.modules:

${module(mod)}\
%   endfor
##
<%def name="alias(node)">\
<%
    if node.ctype in ffi_basic_types:
        if namespace.name in ('GLib', 'GObject'):
            # These redundantly introspect GType
            return ''
        raise ConsistencyError(
            'C type name {} conflicts with a fundamental type'
            .format(node.ctype))
%>
pub type ${node.ctype} = ${mapper.map_aliased_type(node)};
</%def>\
##
<%def name="callback(node)">
pub type ${node.ctype} = ${mapper.map_callback(node)};
</%def>\
##
<%def name="constant(node)">
<%
    value_type, value = mapper.map_constant(node)
%>\
pub const ${node.ctype}: ${value_type} = ${value};
</%def>\
##
<%def name="struct(node)">
%   if isinstance(node, ast.Record) and node.disguised:
#[repr(C)]
pub struct ${node.ctype}(gpointer);
%   elif len(node.fields) == 0:
pub enum ${node.ctype} { }
%   else:
#[repr(C)]
pub struct ${node.ctype} {
%       for field in node.fields:
    ${'' if field.private else 'pub '}${sanitize_ident(field.name)}: ${mapper.map_field_type(field)},
%       endfor
}
%   endif
</%def>\
##
<%def name="interface(node)">
pub enum ${node.ctype} { }
</%def>\
##
<%def name="_enum_common(node, member_const_tmpl)">\
<%
    # Deduplicate the values
    value_name_map = {}
    for member in node.members:
        validate_integer_value(member.value)
        value = int(member.value)
        if value in value_name_map:
            continue
        value_name_map[value] = to_camel_case(member.name)
    if len(value_name_map) == 1:
        # Work around https://github.com/rust-lang/rust/issues/10292
        value = list(value_name_map.keys())[0]
        dummy_value = 0 if value != 0 else 1
        value_name_map[dummy_value] = '_Dummy'
%>\
#[repr(C)]
pub enum ${node.ctype} {
%   for name, value in [(value_name_map[val], val) for val in sorted(value_name_map.keys())]:
    ${name} = ${value},
%   endfor
}
<%
    for member in node.members:
        if member.symbol in self.attr.suppress_c_names:
            continue
        member_const_tmpl(node, member, value_name_map[int(member.value)])
%>\
</%def>\
##
<%def name="enum(node)">
${_enum_common(node, enum_member_const)}\
</%def>\
<%def name="enum_member_const(node, member, value_name)">\
pub const ${member.symbol}: ${node.ctype} = ${node.ctype}::${value_name};
</%def>\
##
<%def name="flags(node)">
${_enum_common(node, flags_member_const)}\
</%def>\
<%def name="flags_member_const(node, member, value_name)">\
## Use the literal value as the enum members cannot be ORed
pub const ${member.symbol}: guint = ${map_constant_value(ast.TYPE_UINT, member.value)};
</%def>\
##
<%def name="gtype_functions(namespace)">\
<%
    func_names = []
    for node in namespace.type_names.values():
        name = node.get_type
        if name is None:
            continue
        if isinstance(node, ast.Class) and node.fundamental:
            continue
        if name == 'intern':
            continue
        func_names.append(name)
    for node in namespace.symbols.values():
        if isinstance(node, ast.Function) and node.is_type_meta_function():
            func_names.append(node.symbol)
    func_names.sort()
%>\
extern {
%   for name in func_names:
    pub fn ${name}() -> GType;
%   endfor
}
</%def>\
##
<%def name="function(node)">\
<%
    parameters = node.all_parameters
    param_list = []
    if len(parameters) > 0 and isinstance(parameters[-1].type, ast.Varargs):
        parameters = parameters[:-1]
        param_list = ['...']
    param_list[:0] = ['{name}: {type}'.format(
                        name=sanitize_ident(param.argname),
                        type=mapper.map_parameter_type(param))
                      for param in parameters]
%>\
pub fn ${node.symbol}(${', '.join(param_list)})\
%   if node.retval.type != ast.TYPE_NONE:
 -> ${mapper.map_return_type(node.retval)}\
%   endif
;
</%def>\
##
<%def name="cfg_attr(cfg)">\
%   if cfg:
#[cfg(${cfg})]
%   endif
</%def>\
##
<%def name="module(mod)">\
${cfg_attr(mod.cfg)}\
pub mod ${mod.name} {
    use gtypes::*;
    use super::*;

    extern {
<%
    for node in sorted(mod.functions, key=lambda node: node.symbol):
        emit_node(function, node, indent=8)
%>\
    }
}
%   if mod.toplevel_export:

${cfg_attr(mod.cfg)}\
pub use ${mod.name}::*;
%   endif
</%def>\
